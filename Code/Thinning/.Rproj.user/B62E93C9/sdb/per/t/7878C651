{
    "collab_server" : "",
    "contents" : "#' readPNGBinary\n#'\n#' This function reads in and binarizes PNG images from the specified file path.\n#' @param path File path for image.\n#' @param binarizationCutoff Value to cut off non binary images. Values higher than this value go to 1 and lower than this value go to 0. 0 by default, no binarization.\n#' @param inversion Boolean dictating whether or not to flip each bin of binarized image. Flipping happens after binarization. FALSE by default.\n#' @keywords PNG, binary\n#' @return Returns image from path. 0 represents black, and 1 represents white by default.\n#' @export \n\nreadPNGBinary = function(path, binarizationCutoff = 0, inversion = FALSE)\n{\n  img = readPNG(path, native = FALSE)\n  img = apply(img, c(1,2), FUN = function(x){1-any(x < 1-binarizationCutoff)})\n  if(inversion == TRUE)\n    img = 1-img\n  return(img)\n}\n\n#' plotImage\n#'\n#' This function plots a basic binary image.\n#' @param x Binary matrix, usually from readPNGBinary\n#' @keywords plot\n#' @return Returns plot of x.\n#' @export\n\nplotImage = function(x)\n{\n  xm = melt(x)\n  p = ggplot(xm, aes(Var2, rev(Var1))) + geom_raster(aes(fill = as.factor(value))) + scale_fill_manual(values = c(\"black\", \"white\"), guide = FALSE) + theme_void()\n  return(p)\n}\n\n#' neighborChanges\n#'\n#' Internal function for thinImage. Counts switches from 1 to 0 around a point.\n#' @param coords Point location.\n#' @param img Image object.\n#' @return Returns count of switches.\n\nneighborChanges = function(coords, img)\n{\n  rr = coords[1]\n  cc = coords[2]\n  if(rr>1 & cc>1 & rr<dim(img)[1] & cc<dim(img)[2])\n  {\n    neighbs = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(2,3,6,9,8,7,4,1,2)]\n    return(sum(neighbs == 1 & c(neighbs[-1], neighbs[1]) == 0))\n  }\n  else\n    return(0)\n}\n\n#' numNeighbors\n#'\n#' Internal function for thinImage. Counts neighbors with value of 0.\n#' @param coords Point location.\n#' @param img Image object.\n#' @return Returns number of 0 neighbors.\n\nnumNeighbors = function(coords, img)\n{\n  rr = coords[1]\n  cc = coords[2]\n  if(rr>1 & cc>1 & rr<dim(img)[1] & cc<dim(img)[2])\n  {\n    neighbs = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(2,3,6,9,8,7,4,1)]\n    return(sum(neighbs == 0))\n  }\n  else\n    return(0)\n}\n\n#' neighbs246468\n#'\n#' Internal function for thinImage. Returns 1 if one of the points to the top, bottom and left AND one of right, bottom, left are non-zero. 0 otherwise.\n#' @param coords Point location.\n#' @param img Image object.\n#' @return Returns 1 or 0 for condition mentioned above.\n#' \nneighbs246468 = function(coords, img)\n{\n  rr = coords[1]\n  cc = coords[2]\n  if(rr>1 & cc>1 & rr<dim(img)[1] & cc<dim(img)[2])\n  {\n    neighbs246 = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(2,6,8)]\n    neighbs468 = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(4,6,8)]\n    return(as.numeric(any(neighbs246 == 1) & any(neighbs468 == 1)))\n  }\n  else\n    return(0)\n}\n\n#' neighbs246468\n#'\n#' Internal function for thinImage. Returns 1 if at least one of the points to the top, right and bottom AND at least one of top, right, left are non-zero. 0 otherwise.\n#' @param coords Point location.\n#' @param img Image object.\n#' @return Returns 1 or 0 for condition mentioned above.\n\nneighbs248268 = function(coords, img)\n{\n  rr = coords[1]\n  cc = coords[2]\n  if(rr>1 & cc>1 & rr<dim(img)[1] & cc<dim(img)[2])\n  {\n    neighbs248 = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(2,4,6)]\n    neighbs268 = c(t(img[(rr-1):(rr+1),][,(cc-1):(cc+1)]))[c(2,4,8)]\n    return(as.numeric(any(neighbs248 == 1) & any(neighbs268 == 1)))\n  }\n  else\n    return(0)\n}\n\n#' stepA\n#'\n#' Internal function for thinImage. First iteration of checks for thinning algorithm\n#' @param img Image object.\n#' @param coords Locations of points to check.\n#' @return TRUE or FALSE for each point in coords, based on if they pass the checks.\n\nstepA = function(img, coords)\n{\n  imgA = matrix(apply(X = coords, MARGIN = 1, FUN = neighborChanges, img = img), byrow = F, nrow = 1)\n  imgB = matrix(apply(X = coords, MARGIN = 1, FUN = numNeighbors, img = img), byrow = F, nrow = 1)\n  img246468 = matrix(apply(X = coords, MARGIN = 1, FUN =  neighbs246468, img = img), byrow = F, nrow = 1)\n  imgFlag = as.numeric(imgB >= 2 & imgB <= 6 & imgA == 1 & img246468 == 1)\n  return(imgFlag)\n}\n\n#' stepA\n#'\n#' Internal function for thinImage. Second iteration of checks for thinning algorithm\n#' @param img Image object.\n#' @param coords Locations of points to check.\n#' @return TRUE or FALSE for each point in coords, based on if they pass the checks.\n\nstepB = function(img, coords)\n{\n  imgA = matrix(apply(X = coords, MARGIN = 1, FUN = neighborChanges, img = img), byrow = F, nrow = 1)\n  imgB = matrix(apply(X = coords, MARGIN = 1, FUN = numNeighbors, img = img), byrow = F, nrow = 1)\n  img248268 = matrix(apply(X = coords, MARGIN = 1, FUN =  neighbs248268, img = img), byrow = F, nrow = 1)\n  imgFlag = as.numeric(imgB >= 2 & imgB <= 6 & imgA == 1 & img248268 == 1)\n  return(imgFlag)\n}\n\n#' thinImage\n#'\n#' Fast implementation of the Zhang-Suen Thinning algorithm (1984).\n#' @param img Binary Image matrix.\n#' @param verbose Whether you want detailed output as code is run. Defaults to FALSE.\n#' @keywords thinning, Zhang, Suen\n#' @return Returns thinned image matrix.\n#' @examples\n#' data(london)\n#' london = crop(london)\n#' london_thin = thinImage(london, verbose = TRUE)\n#' \n#' data(cells)\n#' cells = crop(cells)\n#' cells_thin = thinImage(cells, verbose = TRUE)\n#' \n#' data(message)\n#' message = crop(message)\n#' message_thin = thinImage(message, verbose = TRUE)\n#' \n#' @export \n\nthinImage = function(img, verbose = FALSE)\n{\n  flag = TRUE\n  if(verbose)\n  {\n    iterCount = 1\n    total.time.start = Sys.time()\n  }\n  thinned = img\n  change = which(img == 0)\n  while(flag == TRUE)\n  {\n    if(verbose != FALSE) start.time <- Sys.time()\n    index = change[thinned[change] == 0]\n    img.m = cbind(((index - 1) %% dim(img)[1]) + 1, ((index - 1) %/% dim(img)[1]) + 1)\n    flagA = stepA(thinned, img.m)\n    thinned[index] = ifelse(c(thinned[index] == 0) & flagA == 0, 0, 1)\n    flagB = stepB(thinned, img.m)\n    thinned[index] = ifelse(c(thinned[index] == 0) & flagB == 0, 0, 1)\n    \n    if(sum(flagA + flagB, na.rm = T) == 0)\n    {\n      flag = FALSE\n    }\n    else\n    {\n      change = index[(flagA | flagB)]\n      change = unique(rep(change, each = 9) + rep(c(0,1, -1, dim(img)[1]-1, dim(img)[1]+1, -dim(img)[1]+1, -dim(img)[1]-1, dim(img)[1], -dim(img)[1]), length(change)))\n      change = change[change>=1 & change<=prod(dim(img))]\n    }\n\n    if(verbose == TRUE)\n    {\n      cat(\"\\nIteration\", iterCount, \"done:\", sum(flagA | flagB), \"changes.\")\n      cat(\"\\nLeft to check:\", ifelse(sum(flagA | flagB) != 0, length(change), 0))\n      iterCount = iterCount + 1\n    }\n    flagA[] = 0\n    flagB[] = 0\n    \n    if(verbose == TRUE)\n    {\n      #temp = matrix(1, dim(img)[1], dim(img)[2])\n      #temp[change] = 0\n      #image(temp, main = \"Need to update\")\n      \n      end.time <- Sys.time()\n      cat(\"\\nIteration Time:\", end.time - start.time, \"\\n\")\n    }\n  }\n  if(verbose)\n  {\n    total.time.end = Sys.time()\n    cat(\"\\n------------------------\\nTotal Run Time:\", difftime(total.time.end, total.time.start, units = \"secs\"), \"\\n------------------------\\n\")\n  }\n  return(thinned)\n}\n\n#' plotImageThinned\n#' \n#' This function returns a plot with the full image plotted in light gray and the skeleton printed in black on top.\n#' @param img Full image matrix\n#' @param thinned Thinned image matrix\n#' @return Plot of full and thinned image.\n#' @examples\n#' plotImageThinned(london, london_thin)\n#' plotImageThinned(cells, cells_thin)\n#' plotImageThinned(message, message_thin)\n#' \n#' @export\n\nplotImageThinned = function(img, thinned)\n{\n  l.m = melt(img)\n  t.m = melt(thinned)\n  l.m$value[t.m$value == 0] = 2\n  p = ggplot(l.m, aes(Var2, rev(Var1))) + geom_raster(aes(fill = as.factor(value != 1), alpha = ifelse(value==0,.3,1))) + scale_alpha_continuous(guide = FALSE) + scale_fill_manual(values = c(\"white\", \"black\"), guide = FALSE) + theme_void()\n  return(p)\n}\n\n#' crop\n#' \n#' This function crops an image down so that there is 1 pixel of padding on each side of the outermost 0 points.\n#' @param img Full image matrix to be cropped\n#' @return Cropped image matrix.\n#' \n#' @export\n\ncrop = function(img)\n{\n  if(any(img[,1] != 1)) {img = cbind(rep(1, dim(img)[1]), img)}\n  if(any(img[,dim(img)[2]] != 1)) {img = cbind(img, rep(1, dim(img)[1]))}\n  if(any(img[1,] != 1)) {img = rbind(rep(1, dim(img)[2]), img)}\n  if(any(img[dim(img)[1],] != 1)) {img = rbind(img, rep(1, dim(img)[2]))}\n  \n  rows = apply(img, 1, FUN = function(x){any(x != 1)})\n  cols = apply(img, 2, FUN = function(x){any(x != 1)})\n  x.min = max(which(rows)[1] - 1, 1)\n  x.max = min(which(rows)[sum(rows)] + 1, length(rows))\n  y.min = max(which(cols)[1] - 1, 1)\n  y.max = min(which(cols)[sum(cols)] + 1, length(cols))\n  \n  return(img[x.min:x.max,y.min:y.max])\n}",
    "created" : 1505148503104.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2017633876",
    "id" : "7878C651",
    "lastKnownWriteTime" : 1504042337,
    "last_content_update" : 1504042337,
    "path" : "~/Documents/Projects/CSAFE/handwriter/R/ThinText.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}